const { model, generationConfig } = require('../config/gemini');
const NodeCache = require('node-cache');
const crypto = require('crypto');
const db = require('../config/database');

// Initialize cache with 24-hour TTL
const cache = new NodeCache({ stdTTL: 86400 });

class GeminiService {
  /**
   * Generate a hash for content to use as cache key
   * @param {string} content
   * @returns {string}
   */
  generateContentHash(content) {
    return crypto.createHash('md5').update(content.toLowerCase().trim()).digest('hex');
  }

  /**
   * Generate tags using Gemini API
   * @param {string} jobDescription - Job description text
   * @returns {Promise<string[]>} - Array of tag names (max 3)
   */
  async generateTags(jobDescription) {
    try {
      // Check cache first
      const cacheKey = this.generateContentHash(jobDescription);
      const cachedTags = cache.get(cacheKey);
      
      if (cachedTags) {
        console.log('✓ Tags retrieved from cache');
        return cachedTags;
      }

      // Call Gemini API
      const prompt = `Analyze this job description and return exactly 3 relevant tags as comma-separated values. 
Rules:
1. Detect the language of the description. If it is Vietnamese, return tags in Vietnamese. If it is English, return tags in English.
2. Avoid generic multi-word tags. For example, split "online coaching" into "online", "coaching". Keep technical terms like "React Native" or "Node.js" intact.
3. The tags should represent key skills, technologies, or job characteristics.
4. Only return the tags, nothing else.

Job Description: ${jobDescription}`;

      const result = await model.generateContent(prompt);
      const response = await result.response;
      const text = response.text();

      // Parse tags from response
      const tags = this.parseTags(text);

      // Cache the result
      if (tags.length > 0) {
        cache.set(cacheKey, tags);
      }

      console.log('✓ Tags generated by Gemini:', tags);
      return tags;
    } catch (error) {
      console.error('Gemini API error:', error.message);
      // Return empty array on error instead of throwing
      return [];
    }
  }

  /**
   * Parse tags from Gemini response
   * @param {string} text - Response text from Gemini
   * @returns {string[]} - Array of tag names
   */
  parseTags(text) {
    // Remove any markdown formatting, quotes, or extra characters
    const cleanedText = text
      .replace(/[*`"'\[\]]/g, '')
      .trim();

    // Split by comma and clean up each tag
    const tags = cleanedText
      .split(',')
      .map(tag => tag.trim())
      .filter(tag => tag.length > 0 && tag.length <= 100)
      .slice(0, 3); // Ensure max 3 tags

    return tags;
  }

  /**
   * Find or create tags in database
   * @param {string} tagName - Tag name to find or create
   * @returns {Promise<number>} - Tag ID
   */
  async findOrCreateTag(tagName) {
    try {
      // First, try to find existing tag (case-insensitive)
      const findQuery = 'SELECT id FROM tags WHERE LOWER(name) = LOWER($1)';
      const findResult = await db.query(findQuery, [tagName]);

      if (findResult.rows.length > 0) {
        return findResult.rows[0].id;
      }

      // If not found, create new tag
      const insertQuery = `
        INSERT INTO tags (name, category) 
        VALUES ($1, 'ai-generated') 
        RETURNING id
      `;
      const insertResult = await db.query(insertQuery, [tagName]);
      
      console.log(`✓ New tag created: ${tagName}`);
      return insertResult.rows[0].id;
    } catch (error) {
      // Handle unique constraint violation
      if (error.code === '23505') {
        // Tag was created by another request, fetch it
        const findQuery = 'SELECT id FROM tags WHERE LOWER(name) = LOWER($1)';
        const findResult = await db.query(findQuery, [tagName]);
        return findResult.rows[0].id;
      }
      throw error;
    }
  }

  /**
   * Generate tags and store them in database
   * @param {string} jobDescription - Job description text
   * @returns {Promise<number[]>} - Array of tag IDs
   */
  async generateAndStoreTags(jobDescription) {
    try {
      // Generate tags using Gemini
      const tagNames = await this.generateTags(jobDescription);

      if (tagNames.length === 0) {
        console.warn('No tags generated, returning empty array');
        return [];
      }

      // Find or create each tag and get their IDs
      const tagIds = [];
      for (const tagName of tagNames) {
        const tagId = await this.findOrCreateTag(tagName);
        tagIds.push(tagId);
      }

      return tagIds;
    } catch (error) {
      console.error('Error in generateAndStoreTags:', error);
      return [];
    }
  }

  /**
   * Clear the cache (useful for testing or manual refresh)
   */
  clearCache() {
    cache.flushAll();
    console.log('✓ Tag generation cache cleared');
  }
}

module.exports = new GeminiService();
